{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import * as core from \"@actions/core\";\nimport * as exec from \"@actions/exec\";\n\ntype TemplateContext = Record<string, string | undefined>;\n\ninterface ParsedWranglerOutput {\n  deploymentUrl?: string;\n  versionId?: string;\n}\n\ninterface DeployMetadata {\n  owner?: string;\n  repo?: string;\n  ref?: string;\n  branch?: string;\n  sha?: string;\n  short_sha?: string;\n  actor?: string;\n  run_id?: string;\n  run_number?: string;\n  commit_message?: string;\n  short_commit_message?: string;\n}\n\nasync function run(): Promise<void> {\n  try {\n    const apiToken = core.getInput(\"api_token\", { required: true });\n    const wranglerCommandInput = core.getInput(\"wrangler_command\", {\n      required: true,\n    });\n    const workingDirectoryInput = core.getInput(\"working_directory\") || \"\";\n    const onlyUploadInput = core.getInput(\"only_upload\") || \"false\";\n    const onlyUpload = onlyUploadInput.toLowerCase() === \"true\";\n    const config = core.getInput(\"config\", { required: true });\n    const uploadArgsRaw = core.getInput(\"upload_args\") || \"\";\n    const deployArgsRaw = core.getInput(\"deploy_args\") || \"\";\n    const messageTemplate = core.getInput(\"message_template\") || \"\";\n    const tagTemplate = core.getInput(\"tag_template\") || \"\";\n\n    const uploadArgsList = splitArgs(uploadArgsRaw);\n    const deployArgsList = splitArgs(deployArgsRaw);\n\n    const workingDirectory =\n      workingDirectoryInput.trim().length > 0\n        ? workingDirectoryInput.trim()\n        : undefined;\n\n    const wranglerCommand = wranglerCommandInput.trim();\n\n    if (!apiToken) {\n      core.setFailed(\"Cloudflare API token (api_token) is required.\");\n      return;\n    }\n\n    // Collect metadata from the GitHub environment and git.\n    const metadata = await collectMetadata();\n\n    // Log basic context for transparency (no secrets).\n    core.info(\n      [\n        `Repository: ${metadata.owner ?? \"unknown\"}/${metadata.repo ?? \"unknown\"}`,\n        `Branch: ${metadata.branch ?? metadata.ref ?? \"unknown\"}`,\n        `SHA: ${metadata.sha ?? \"unknown\"}`,\n        `Actor: ${metadata.actor ?? \"unknown\"}`,\n        `Run: #${metadata.run_number ?? \"?\"} (ID: ${metadata.run_id ?? \"?\"})`,\n      ].join(\" | \"),\n    );\n\n    // Prepare Wrangler args from inputs (already parsed above).\n\n    // 1) Build message and tag from templates + metadata (no deployment data yet).\n    const preTemplateContext: TemplateContext = {\n      ...metadata,\n      deployment_url: undefined,\n      version_id: undefined,\n    };\n\n    const renderedMessage = messageTemplate\n      ? renderTemplate(messageTemplate, preTemplateContext)\n      : buildDefaultMessage(metadata);\n    const renderedTag = tagTemplate\n      ? renderTemplate(tagTemplate, preTemplateContext)\n      : buildDefaultTag(metadata);\n\n    core.info(`Using deployment message: ${renderedMessage}`);\n    if (renderedTag) {\n      core.info(`Using deployment tag: ${renderedTag}`);\n    }\n\n    // 2) Run `wrangler versions upload` to create a new version with metadata.\n    // We assume the user is on Wrangler v4+ and that `versions` commands are available.\n    // The actual Worker configuration (e.g. wrangler.toml) is controlled by the caller.\n    const uploadArgs = [\n      \"versions\",\n      \"upload\",\n      ...(config ? [\"--config\", config] : []),\n      ...uploadArgsList,\n      `--message=${renderedMessage}`,\n    ];\n\n    core.info(`Running upload: ${wranglerCommand} ${uploadArgs.join(\" \")}`);\n\n    let uploadStdout = \"\";\n    let uploadStderr = \"\";\n\n    const uploadOptions: exec.ExecOptions = {\n      env: {\n        ...process.env,\n        CLOUDFLARE_API_TOKEN: apiToken,\n      },\n      cwd: workingDirectory,\n      listeners: {\n        stdout: (data: Buffer) => {\n          const text = data.toString();\n          uploadStdout += text;\n          // Do not re-echo stdout here to avoid duplicate logs; Wrangler already prints to the console.\n        },\n        stderr: (data: Buffer) => {\n          const text = data.toString();\n          uploadStderr += text;\n        },\n      },\n    };\n\n    const uploadExitCode = await exec.exec(\n      wranglerCommand,\n      uploadArgs,\n      uploadOptions,\n    );\n\n    if (uploadExitCode !== 0) {\n      if (uploadStderr.trim()) {\n        core.error(uploadStderr.trimEnd());\n      }\n      core.setFailed(\n        `wrangler versions upload failed with exit code ${uploadExitCode}. See logs above for details.`,\n      );\n      return;\n    }\n\n    const versionId = parseVersionIdFromUpload(uploadStdout);\n\n    if (onlyUpload) {\n      if (versionId) {\n        core.info(`Parsed Worker Version ID (only_upload=true): ${versionId}`);\n        core.setOutput(\"version_id\", versionId);\n      } else {\n        core.info(\n          \"only_upload=true and no Worker Version ID could be parsed; exiting successfully.\",\n        );\n      }\n\n      if (renderedMessage) {\n        core.setOutput(\"message\", renderedMessage);\n      }\n      if (renderedTag) {\n        core.setOutput(\"tag\", renderedTag);\n      }\n\n      return;\n    }\n\n    if (!versionId) {\n      core.setFailed(\n        \"Failed to parse Worker Version ID from wrangler versions upload output.\",\n      );\n      return;\n    }\n    core.info(`Parsed Worker Version ID: ${versionId}`);\n\n    // 3) Run `wrangler versions deploy <versionId>` non-interactively with the same message.\n    const deployArgs = [\n      \"versions\",\n      \"deploy\",\n      versionId,\n      \"-y\",\n      ...(config ? [\"--config\", config] : []),\n      ...deployArgsList,\n      `--message=${renderedMessage}`,\n    ];\n\n    core.info(`Running deploy: ${wranglerCommand} ${deployArgs.join(\" \")}`);\n\n    let deployStdout = \"\";\n    let deployStderr = \"\";\n\n    const deployOptions: exec.ExecOptions = {\n      env: {\n        ...process.env,\n        CLOUDFLARE_API_TOKEN: apiToken,\n      },\n      cwd: workingDirectory,\n      listeners: {\n        stdout: (data: Buffer) => {\n          const text = data.toString();\n          deployStdout += text;\n          // Do not re-echo stdout here to avoid duplicate logs; Wrangler already prints to the console.\n        },\n        stderr: (data: Buffer) => {\n          const text = data.toString();\n          deployStderr += text;\n        },\n      },\n    };\n\n    const deployExitCode = await exec.exec(\n      wranglerCommand,\n      deployArgs,\n      deployOptions,\n    );\n\n    if (deployExitCode !== 0) {\n      if (deployStderr.trim()) {\n        core.error(deployStderr.trimEnd());\n      }\n      core.setFailed(\n        `wrangler versions deploy failed with exit code ${deployExitCode}. See logs above for details.`,\n      );\n      return;\n    }\n\n    const { deploymentUrl } = parseWranglerOutput(deployStdout);\n\n    if (deploymentUrl) {\n      core.info(`Detected deployment URL: ${deploymentUrl}`);\n      core.setOutput(\"deployment_url\", deploymentUrl);\n    } else {\n      core.info(\n        \"No deployment URL detected from Wrangler deploy output. If this is unexpected, please open an issue with example logs.\",\n      );\n    }\n\n    // Expose core metadata outputs for downstream steps.\n    core.setOutput(\"version_id\", versionId);\n    if (renderedMessage) {\n      core.setOutput(\"message\", renderedMessage);\n    }\n    if (renderedTag) {\n      core.setOutput(\"tag\", renderedTag);\n    }\n  } catch (unknownError) {\n    const error = toError(unknownError);\n    core.setFailed(error.message || String(error));\n  }\n}\n\n/**\n * Collect GitHub Actions + git metadata used for templating.\n */\nasync function collectMetadata(): Promise<DeployMetadata> {\n  const repoFull = process.env.GITHUB_REPOSITORY;\n  const [owner, repoName] = repoFull\n    ? repoFull.split(\"/\")\n    : [undefined, undefined];\n\n  const sha = process.env.GITHUB_SHA;\n  const short_sha = sha ? sha.substring(0, 7) : undefined;\n\n  const ref = process.env.GITHUB_REF;\n  const branch =\n    ref && ref.startsWith(\"refs/heads/\")\n      ? ref.substring(\"refs/heads/\".length)\n      : undefined;\n\n  const actor = process.env.GITHUB_ACTOR;\n  const run_id = process.env.GITHUB_RUN_ID;\n  const run_number = process.env.GITHUB_RUN_NUMBER;\n\n  const commit_message = await getLastCommitMessage();\n  const short_commit_message = commit_message\n    ? commit_message.split(\"\\n\")[0]\n    : undefined;\n\n  return {\n    repo: repoName,\n    owner,\n    ref,\n    branch,\n    sha,\n    short_sha,\n    actor,\n    run_id,\n    run_number,\n    commit_message,\n    short_commit_message,\n  };\n}\n\n/**\n * Get the last commit message from git, if available.\n */\nasync function getLastCommitMessage(): Promise<string | undefined> {\n  try {\n    let message = \"\";\n    await exec.exec(\"git\", [\"log\", \"-1\", \"--pretty=%B\"], {\n      listeners: {\n        stdout: (data: Buffer) => {\n          message += data.toString();\n        },\n      },\n      silent: true,\n    });\n    const trimmed = message.trim();\n    return trimmed.length > 0 ? trimmed : undefined;\n  } catch {\n    // If git is not available or this fails, just return undefined.\n    return undefined;\n  }\n}\n\n/**\n * Render a simple {{var}} template string from a context object.\n *\n * Unknown variables are rendered as empty strings to keep messages clean.\n */\nfunction renderTemplate(template: string, context: TemplateContext): string {\n  return template.replace(\n    /{{\\s*([a-zA-Z0-9_]+)\\s*}}/g,\n    (_match, key: string) => {\n      const value = context[key];\n      return value !== undefined ? String(value) : \"\";\n    },\n  );\n}\n\n/**\n * Split a raw argument string into an argv array.\n * Handles basic quoting; this is intentionally simple but robust enough\n * for typical flag usage (`--env production`, etc).\n */\nfunction splitArgs(raw: string): string[] {\n  if (!raw.trim()) return [];\n\n  const args: string[] = [];\n  let current = \"\";\n  let quote: '\"' | \"'\" | null = null;\n\n  for (let i = 0; i < raw.length; i++) {\n    const ch = raw[i];\n\n    if (quote) {\n      if (ch === quote) {\n        quote = null;\n      } else {\n        current += ch;\n      }\n      continue;\n    }\n\n    if (ch === \"'\" || ch === '\"') {\n      quote = ch;\n      continue;\n    }\n\n    if (/\\s/.test(ch)) {\n      if (current) {\n        args.push(current);\n        current = \"\";\n      }\n      continue;\n    }\n\n    current += ch;\n  }\n\n  if (current) {\n    args.push(current);\n  }\n\n  return args;\n}\n\n/**\n * Parse deployment URL from Wrangler output.\n * This remains a best-effort heuristic until we rely on a stable structured format.\n */\nfunction parseWranglerOutput(output: string): ParsedWranglerOutput {\n  const result: ParsedWranglerOutput = {};\n\n  // Heuristic: first URL-looking token is likely the deployment URL.\n  const urlMatch = output.match(/https?:\\/\\/[^\\s\"]+/);\n  if (urlMatch) {\n    result.deploymentUrl = urlMatch[0];\n  }\n\n  return result;\n}\n\n/**\n * Parse Worker Version ID from `wrangler versions upload` output.\n * Mirrors the behavior from the standalone deploy-cloudflare-version script.\n */\nfunction parseVersionIdFromUpload(output: string): string | undefined {\n  const match = output.match(/Worker Version ID:\\s*([0-9a-fA-F-]+)/);\n  return match?.[1];\n}\n\n/**\n * Build a simple default message when no explicit template is provided.\n * Format: branch@sha6: first-line-of-commit-message (trimmed).\n */\nfunction buildDefaultMessage(meta: DeployMetadata): string {\n  const branch = meta.branch || \"\";\n  const shortSha = meta.short_sha || (meta.sha ? meta.sha.substring(0, 6) : \"\");\n  const baseMessage = meta.short_commit_message || meta.commit_message || \"\";\n\n  const prefixParts: string[] = [];\n  if (branch) {\n    if (shortSha) {\n      prefixParts.push(`${branch}@${shortSha}`);\n    } else {\n      prefixParts.push(branch);\n    }\n  } else if (shortSha) {\n    prefixParts.push(shortSha);\n  }\n\n  const prefix = prefixParts.join(\"\");\n  const combined = prefix ? `${prefix}: ${baseMessage}` : baseMessage;\n\n  return combined.slice(0, 100);\n}\n\n/**\n * Build a compact default tag when no tag_template is provided.\n * By default, this action does not generate a tag, so this returns an empty string.\n */\nfunction buildDefaultTag(_meta: DeployMetadata): string {\n  return \"\";\n}\n\nfunction toError(e: unknown): Error {\n  if (e instanceof Error) return e;\n  return new Error(typeof e === \"string\" ? e : \"Unknown error\");\n}\n\nvoid run();\n"],"mappings":"wdAAA,IAAAA,EAAsB,4BACtBC,EAAsB,4BAuBtB,eAAeC,GAAqB,CAClC,GAAI,CACF,IAAMC,EAAgB,WAAS,YAAa,CAAE,SAAU,EAAK,CAAC,EACxDC,EAA4B,WAAS,mBAAoB,CAC7D,SAAU,EACZ,CAAC,EACKC,EAA6B,WAAS,mBAAmB,GAAK,GAE9DC,GADuB,WAAS,aAAa,GAAK,SACrB,YAAY,IAAM,OAC/CC,EAAc,WAAS,SAAU,CAAE,SAAU,EAAK,CAAC,EACnDC,EAAqB,WAAS,aAAa,GAAK,GAChDC,EAAqB,WAAS,aAAa,GAAK,GAChDC,EAAuB,WAAS,kBAAkB,GAAK,GACvDC,EAAmB,WAAS,cAAc,GAAK,GAE/CC,EAAiBC,EAAUL,CAAa,EACxCM,EAAiBD,EAAUJ,CAAa,EAExCM,EACJV,EAAsB,KAAK,EAAE,OAAS,EAClCA,EAAsB,KAAK,EAC3B,OAEAW,EAAkBZ,EAAqB,KAAK,EAElD,GAAI,CAACD,EAAU,CACR,YAAU,+CAA+C,EAC9D,MACF,CAGA,IAAMc,EAAW,MAAMC,EAAgB,EAGlC,OACH,CACE,eAAeD,EAAS,OAAS,SAAS,IAAIA,EAAS,MAAQ,SAAS,GACxE,WAAWA,EAAS,QAAUA,EAAS,KAAO,SAAS,GACvD,QAAQA,EAAS,KAAO,SAAS,GACjC,UAAUA,EAAS,OAAS,SAAS,GACrC,SAASA,EAAS,YAAc,GAAG,SAASA,EAAS,QAAU,GAAG,GACpE,EAAE,KAAK,KAAK,CACd,EAKA,IAAME,EAAsC,CAC1C,GAAGF,EACH,eAAgB,OAChB,WAAY,MACd,EAEMG,EAAkBV,EACpBW,EAAeX,EAAiBS,CAAkB,EAClDG,EAAoBL,CAAQ,EAC1BM,EAAcZ,EAChBU,EAAeV,EAAaQ,CAAkB,EAC9CK,EAAgBP,CAAQ,EAEvB,OAAK,6BAA6BG,CAAe,EAAE,EACpDG,GACG,OAAK,yBAAyBA,CAAW,EAAE,EAMlD,IAAME,EAAa,CACjB,WACA,SACA,GAAIlB,EAAS,CAAC,WAAYA,CAAM,EAAI,CAAC,EACrC,GAAGK,EACH,aAAaQ,CAAe,EAC9B,EAEK,OAAK,mBAAmBJ,CAAe,IAAIS,EAAW,KAAK,GAAG,CAAC,EAAE,EAEtE,IAAIC,EAAe,GACfC,EAAe,GAEbC,EAAkC,CACtC,IAAK,CACH,GAAG,QAAQ,IACX,qBAAsBzB,CACxB,EACA,IAAKY,EACL,UAAW,CACT,OAASc,GAAiB,CACxB,IAAMC,EAAOD,EAAK,SAAS,EAC3BH,GAAgBI,CAElB,EACA,OAASD,GAAiB,CACxB,IAAMC,EAAOD,EAAK,SAAS,EAC3BF,GAAgBG,CAClB,CACF,CACF,EAEMC,EAAiB,MAAW,OAChCf,EACAS,EACAG,CACF,EAEA,GAAIG,IAAmB,EAAG,CACpBJ,EAAa,KAAK,GACf,QAAMA,EAAa,QAAQ,CAAC,EAE9B,YACH,kDAAkDI,CAAc,+BAClE,EACA,MACF,CAEA,IAAMC,EAAYC,EAAyBP,CAAY,EAEvD,GAAIpB,EAAY,CACV0B,GACG,OAAK,gDAAgDA,CAAS,EAAE,EAChE,YAAU,aAAcA,CAAS,GAEjC,OACH,kFACF,EAGEZ,GACG,YAAU,UAAWA,CAAe,EAEvCG,GACG,YAAU,MAAOA,CAAW,EAGnC,MACF,CAEA,GAAI,CAACS,EAAW,CACT,YACH,yEACF,EACA,MACF,CACK,OAAK,6BAA6BA,CAAS,EAAE,EAGlD,IAAME,EAAa,CACjB,WACA,SACAF,EACA,KACA,GAAIzB,EAAS,CAAC,WAAYA,CAAM,EAAI,CAAC,EACrC,GAAGO,EACH,aAAaM,CAAe,EAC9B,EAEK,OAAK,mBAAmBJ,CAAe,IAAIkB,EAAW,KAAK,GAAG,CAAC,EAAE,EAEtE,IAAIC,EAAe,GACfC,EAAe,GAEbC,EAAkC,CACtC,IAAK,CACH,GAAG,QAAQ,IACX,qBAAsBlC,CACxB,EACA,IAAKY,EACL,UAAW,CACT,OAASc,GAAiB,CACxB,IAAMC,EAAOD,EAAK,SAAS,EAC3BM,GAAgBL,CAElB,EACA,OAASD,GAAiB,CACxB,IAAMC,EAAOD,EAAK,SAAS,EAC3BO,GAAgBN,CAClB,CACF,CACF,EAEMQ,EAAiB,MAAW,OAChCtB,EACAkB,EACAG,CACF,EAEA,GAAIC,IAAmB,EAAG,CACpBF,EAAa,KAAK,GACf,QAAMA,EAAa,QAAQ,CAAC,EAE9B,YACH,kDAAkDE,CAAc,+BAClE,EACA,MACF,CAEA,GAAM,CAAE,cAAAC,CAAc,EAAIC,EAAoBL,CAAY,EAEtDI,GACG,OAAK,4BAA4BA,CAAa,EAAE,EAChD,YAAU,iBAAkBA,CAAa,GAEzC,OACH,wHACF,EAIG,YAAU,aAAcP,CAAS,EAClCZ,GACG,YAAU,UAAWA,CAAe,EAEvCG,GACG,YAAU,MAAOA,CAAW,CAErC,OAASkB,EAAc,CACrB,IAAMC,EAAQC,EAAQF,CAAY,EAC7B,YAAUC,EAAM,SAAW,OAAOA,CAAK,CAAC,CAC/C,CACF,CAKA,eAAexB,GAA2C,CACxD,IAAM0B,EAAW,QAAQ,IAAI,kBACvB,CAACC,EAAOC,CAAQ,EAAIF,EACtBA,EAAS,MAAM,GAAG,EAClB,CAAC,OAAW,MAAS,EAEnBG,EAAM,QAAQ,IAAI,WAClBC,EAAYD,EAAMA,EAAI,UAAU,EAAG,CAAC,EAAI,OAExCE,EAAM,QAAQ,IAAI,WAClBC,EACJD,GAAOA,EAAI,WAAW,aAAa,EAC/BA,EAAI,UAAU,EAAoB,EAClC,OAEAE,EAAQ,QAAQ,IAAI,aACpBC,EAAS,QAAQ,IAAI,cACrBC,EAAa,QAAQ,IAAI,kBAEzBC,EAAiB,MAAMC,EAAqB,EAC5CC,EAAuBF,EACzBA,EAAe,MAAM;AAAA,CAAI,EAAE,CAAC,EAC5B,OAEJ,MAAO,CACL,KAAMR,EACN,MAAAD,EACA,IAAAI,EACA,OAAAC,EACA,IAAAH,EACA,UAAAC,EACA,MAAAG,EACA,OAAAC,EACA,WAAAC,EACA,eAAAC,EACA,qBAAAE,CACF,CACF,CAKA,eAAeD,GAAoD,CACjE,GAAI,CACF,IAAIE,EAAU,GACd,MAAW,OAAK,MAAO,CAAC,MAAO,KAAM,aAAa,EAAG,CACnD,UAAW,CACT,OAAS5B,GAAiB,CACxB4B,GAAW5B,EAAK,SAAS,CAC3B,CACF,EACA,OAAQ,EACV,CAAC,EACD,IAAM6B,EAAUD,EAAQ,KAAK,EAC7B,OAAOC,EAAQ,OAAS,EAAIA,EAAU,MACxC,MAAQ,CAEN,MACF,CACF,CAOA,SAASrC,EAAesC,EAAkBC,EAAkC,CAC1E,OAAOD,EAAS,QACd,6BACA,CAACE,EAAQC,IAAgB,CACvB,IAAMC,EAAQH,EAAQE,CAAG,EACzB,OAAOC,IAAU,OAAY,OAAOA,CAAK,EAAI,EAC/C,CACF,CACF,CAOA,SAASlD,EAAUmD,EAAuB,CACxC,GAAI,CAACA,EAAI,KAAK,EAAG,MAAO,CAAC,EAEzB,IAAMC,EAAiB,CAAC,EACpBC,EAAU,GACVC,EAA0B,KAE9B,QAASC,EAAI,EAAGA,EAAIJ,EAAI,OAAQI,IAAK,CACnC,IAAMC,EAAKL,EAAII,CAAC,EAEhB,GAAID,EAAO,CACLE,IAAOF,EACTA,EAAQ,KAERD,GAAWG,EAEb,QACF,CAEA,GAAIA,IAAO,KAAOA,IAAO,IAAK,CAC5BF,EAAQE,EACR,QACF,CAEA,GAAI,KAAK,KAAKA,CAAE,EAAG,CACbH,IACFD,EAAK,KAAKC,CAAO,EACjBA,EAAU,IAEZ,QACF,CAEAA,GAAWG,CACb,CAEA,OAAIH,GACFD,EAAK,KAAKC,CAAO,EAGZD,CACT,CAMA,SAASzB,EAAoB8B,EAAsC,CACjE,IAAMC,EAA+B,CAAC,EAGhCC,EAAWF,EAAO,MAAM,oBAAoB,EAClD,OAAIE,IACFD,EAAO,cAAgBC,EAAS,CAAC,GAG5BD,CACT,CAMA,SAAStC,EAAyBqC,EAAoC,CAEpE,OADcA,EAAO,MAAM,sCAAsC,IAClD,CAAC,CAClB,CAMA,SAAShD,EAAoBmD,EAA8B,CACzD,IAAMvB,EAASuB,EAAK,QAAU,GACxBC,EAAWD,EAAK,YAAcA,EAAK,IAAMA,EAAK,IAAI,UAAU,EAAG,CAAC,EAAI,IACpEE,EAAcF,EAAK,sBAAwBA,EAAK,gBAAkB,GAElEG,EAAwB,CAAC,EAC3B1B,EACEwB,EACFE,EAAY,KAAK,GAAG1B,CAAM,IAAIwB,CAAQ,EAAE,EAExCE,EAAY,KAAK1B,CAAM,EAEhBwB,GACTE,EAAY,KAAKF,CAAQ,EAG3B,IAAMG,EAASD,EAAY,KAAK,EAAE,EAGlC,OAFiBC,EAAS,GAAGA,CAAM,KAAKF,CAAW,GAAKA,GAExC,MAAM,EAAG,GAAG,CAC9B,CAMA,SAASnD,EAAgBsD,EAA+B,CACtD,MAAO,EACT,CAEA,SAASnC,EAAQ,EAAmB,CAClC,OAAI,aAAa,MAAc,EACxB,IAAI,MAAM,OAAO,GAAM,SAAW,EAAI,eAAe,CAC9D,CAEKzC,EAAI","names":["core","exec","run","apiToken","wranglerCommandInput","workingDirectoryInput","onlyUpload","config","uploadArgsRaw","deployArgsRaw","messageTemplate","tagTemplate","uploadArgsList","splitArgs","deployArgsList","workingDirectory","wranglerCommand","metadata","collectMetadata","preTemplateContext","renderedMessage","renderTemplate","buildDefaultMessage","renderedTag","buildDefaultTag","uploadArgs","uploadStdout","uploadStderr","uploadOptions","data","text","uploadExitCode","versionId","parseVersionIdFromUpload","deployArgs","deployStdout","deployStderr","deployOptions","deployExitCode","deploymentUrl","parseWranglerOutput","unknownError","error","toError","repoFull","owner","repoName","sha","short_sha","ref","branch","actor","run_id","run_number","commit_message","getLastCommitMessage","short_commit_message","message","trimmed","template","context","_match","key","value","raw","args","current","quote","i","ch","output","result","urlMatch","meta","shortSha","baseMessage","prefixParts","prefix","_meta"]}